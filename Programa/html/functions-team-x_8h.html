<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trabalho Laboratórios de Programação: Referência ao ficheiro functions-team-x.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Trabalho Laboratórios de Programação
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Carregando...</div>
<div class="SRStatus" id="Searching">Procurando...</div>
<div class="SRStatus" id="NoMatches">Nenhuma entrada encontrada</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Funções</a>  </div>
  <div class="headertitle"><div class="title">Referência ao ficheiro functions-team-x.h</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
Este grafo mostra quais são os ficheiros que incluem directamente ou indirectamente este ficheiro:</div>
<div class="dyncontent">
<div class="center"><img src="functions-team-x_8h__dep__incl.png" border="0" usemap="#afunctions-team-x_8hdep" alt=""/></div>
<map name="afunctions-team-x_8hdep" id="afunctions-team-x_8hdep">
<area shape="rect" title=" " alt="" coords="82,5,229,31"/>
<area shape="rect" href="functions-team-x_8c.html" title="Ficheiro que contem a implementação de todas as funções do projeto." alt="" coords="5,79,151,104"/>
<area shape="poly" title=" " alt="" coords="135,42,92,80,89,76,131,38"/>
<area shape="rect" href="main-team-x_8c.html" title=" " alt="" coords="175,79,293,104"/>
<area shape="poly" title=" " alt="" coords="180,38,223,76,219,80,176,42"/>
</map>
</div>
</div>
<p><a href="functions-team-x_8h_source.html">Ir para o código fonte deste ficheiro.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funções</h2></td></tr>
<tr class="memitem:accfbc9488bd94bcc83bca519246b9218" id="r_accfbc9488bd94bcc83bca519246b9218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#accfbc9488bd94bcc83bca519246b9218">matriz4por18</a> (int VET[], int n)</td></tr>
<tr class="memdesc:accfbc9488bd94bcc83bca519246b9218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função constrói uma matriz do tipo quatro por dezoito, em que cada linha é composta pelo vetor lido.  <br /></td></tr>
<tr class="separator:accfbc9488bd94bcc83bca519246b9218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bd51b8eaa11070bcaa53a1b4512d4b" id="r_a83bd51b8eaa11070bcaa53a1b4512d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a83bd51b8eaa11070bcaa53a1b4512d4b">funcaolog</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a83bd51b8eaa11070bcaa53a1b4512d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função calcula o logaritmo de base natural dos elementos do vetor.  <br /></td></tr>
<tr class="separator:a83bd51b8eaa11070bcaa53a1b4512d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7727241be4ebbdeab4645b5a48a2c5b0" id="r_a7727241be4ebbdeab4645b5a48a2c5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a7727241be4ebbdeab4645b5a48a2c5b0">mediana</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a7727241be4ebbdeab4645b5a48a2c5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculo da mediana dos elementos no vetor.  <br /></td></tr>
<tr class="separator:a7727241be4ebbdeab4645b5a48a2c5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231ecd5239a28be99f55b277d1a87ba9" id="r_a231ecd5239a28be99f55b277d1a87ba9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a231ecd5239a28be99f55b277d1a87ba9">ordenarsimetricos</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a231ecd5239a28be99f55b277d1a87ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função recebe o vetor com 18 valores dados pelo utilizador e ordena-os por ordem crescente dos seus valores simétricos.  <br /></td></tr>
<tr class="separator:a231ecd5239a28be99f55b277d1a87ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f87183a209e839b01dfd93d72571030" id="r_a2f87183a209e839b01dfd93d72571030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a2f87183a209e839b01dfd93d72571030">MdoisDcinco</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a2f87183a209e839b01dfd93d72571030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função devolve os valores que são maiores que dois e divisíveis por cinco.  <br /></td></tr>
<tr class="separator:a2f87183a209e839b01dfd93d72571030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c78ecb1a4af1d7b03ef6708922419" id="r_a208c78ecb1a4af1d7b03ef6708922419"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a208c78ecb1a4af1d7b03ef6708922419">somametades</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a208c78ecb1a4af1d7b03ef6708922419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função soma a primeira metade do vetor com a sua segunda criando um vetor com metade do tamanho.  <br /></td></tr>
<tr class="separator:a208c78ecb1a4af1d7b03ef6708922419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac563eb36d460eb5f154bad1a3d5dae" id="r_abac563eb36d460eb5f154bad1a3d5dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#abac563eb36d460eb5f154bad1a3d5dae">ajuda</a> (int n)</td></tr>
<tr class="memdesc:abac563eb36d460eb5f154bad1a3d5dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta paginá contém as regras de utilização do programa e também instruções para o utilizar de forma correta.  <br /></td></tr>
<tr class="separator:abac563eb36d460eb5f154bad1a3d5dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c61fb9ebb5d421733e5ecf3868e0661" id="r_a6c61fb9ebb5d421733e5ecf3868e0661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a6c61fb9ebb5d421733e5ecf3868e0661">novomistura</a> (int VET[], int n)</td></tr>
<tr class="memdesc:a6c61fb9ebb5d421733e5ecf3868e0661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função pede que seja introduzidos 18 novos valores para um novo vetor, e de seguida mistura metade do vetor principal com metade desse novo vetor.  <br /></td></tr>
<tr class="separator:a6c61fb9ebb5d421733e5ecf3868e0661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53169018ee03833e4a7744484f529a02" id="r_a53169018ee03833e4a7744484f529a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#a53169018ee03833e4a7744484f529a02">decomporprimos</a> (int n)</td></tr>
<tr class="memdesc:a53169018ee03833e4a7744484f529a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta função decompõe um número inteiro positivo nos seus fatores primos.  <br /></td></tr>
<tr class="separator:a53169018ee03833e4a7744484f529a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f89ea9a2a8e8913a5a7b3d4ba04ca1" id="r_ad8f89ea9a2a8e8913a5a7b3d4ba04ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="functions-team-x_8h.html#ad8f89ea9a2a8e8913a5a7b3d4ba04ca1">decomporVetorImpares</a> (int V[], int n)</td></tr>
<tr class="separator:ad8f89ea9a2a8e8913a5a7b3d4ba04ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentação das funções</h2>
<a id="abac563eb36d460eb5f154bad1a3d5dae" name="abac563eb36d460eb5f154bad1a3d5dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac563eb36d460eb5f154bad1a3d5dae">&#9670;&#160;</a></span>ajuda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ajuda </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta paginá contém as regras de utilização do programa e também instruções para o utilizar de forma correta. </p>
<p>Explica o funcionamento do programa, as regras de colocação de valores para os vetores pedidos e também como aceder e executar de forma correta as funções que o mesmo disponibiliza.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>é o tamanho do vetor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53169018ee03833e4a7744484f529a02" name="a53169018ee03833e4a7744484f529a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53169018ee03833e4a7744484f529a02">&#9670;&#160;</a></span>decomporprimos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decomporprimos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função decompõe um número inteiro positivo nos seus fatores primos. </p>
<p>Esta função ignora o fator primo 2. Ela começa a testar a divisibilidade por 3. Portanto, só funcionará corretamente para números ímpares ou números pares que são também múltiplos de 3 ou de primos ímpares maiores. O caso especial para n=1 é tratado.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>O número inteiro positivo em análise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>número inteiro positivo decomposto em fatores primos. </dd></dl>

</div>
</div>
<a id="ad8f89ea9a2a8e8913a5a7b3d4ba04ca1" name="ad8f89ea9a2a8e8913a5a7b3d4ba04ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f89ea9a2a8e8913a5a7b3d4ba04ca1">&#9670;&#160;</a></span>decomporVetorImpares()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void decomporVetorImpares </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>V</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Esta função percorre o vetor principal e seleciona apenas os números ímpares. Depois utiliza a função "decomporprimos" para decompor esses números ímpares em números primos.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>Os números ímpares do vetor decompostos em números primos. </dd></dl>

</div>
</div>
<a id="a83bd51b8eaa11070bcaa53a1b4512d4b" name="a83bd51b8eaa11070bcaa53a1b4512d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83bd51b8eaa11070bcaa53a1b4512d4b">&#9670;&#160;</a></span>funcaolog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void funcaolog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função calcula o logaritmo de base natural dos elementos do vetor. </p>
<p>Esta função recebe os valores do vetor principal com 18 números dados pelo utilizador percorrendo os mesmos e, recorrendo ao uso da biblioteca "math.h", calcula o logaritmo de base natural de cada um dos elementos do vetor. De seguida esses mesmo valores na tela do usuario.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>O valor do logaritmo base de cada elemento do vetor. </dd></dl>

</div>
</div>
<a id="accfbc9488bd94bcc83bca519246b9218" name="accfbc9488bd94bcc83bca519246b9218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfbc9488bd94bcc83bca519246b9218">&#9670;&#160;</a></span>matriz4por18()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matriz4por18 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função constrói uma matriz do tipo quatro por dezoito, em que cada linha é composta pelo vetor lido. </p>
<p>A função solicita ao utilizador do tipo quatro por dezoito, a introdução de um único vetor de dezoito inteiros, que será armazenado na primeira linha da matriz. As três linhas restantes não são lidas, em vez disso, são preenchidas automaticamente com cópias exatas do primeiro vetor. No final, a matriz resultante contém quatro linhas idênticas.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>Trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>Devolve a matriz já elaborada com os números inteiros posterirmente introduzidos. </dd></dl>

</div>
</div>
<a id="a2f87183a209e839b01dfd93d72571030" name="a2f87183a209e839b01dfd93d72571030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f87183a209e839b01dfd93d72571030">&#9670;&#160;</a></span>MdoisDcinco()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MdoisDcinco </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função devolve os valores que são maiores que dois e divisíveis por cinco. </p>
<p>Esta função recebe o vetor com 18 valores dados pelo utilizador e verifica quais deles são maiores que dois e divisíveis por cinco. De seguida, apresenta esses valores ao utilizador, caso não haja nenhum valor aparece uma mensagem para demonstrar essa situação, "Nenhum valor encontrado".</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>os elementos do vetor que são maiores que dois e divisíveis por cinco, caso existam. </dd></dl>

</div>
</div>
<a id="a7727241be4ebbdeab4645b5a48a2c5b0" name="a7727241be4ebbdeab4645b5a48a2c5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7727241be4ebbdeab4645b5a48a2c5b0">&#9670;&#160;</a></span>mediana()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mediana </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculo da mediana dos elementos no vetor. </p>
<p>Esta função recebe um vetor de números e determina a sua mediana. Para isso, os elementos são primeiro organizados por ordem crescente. Se o número de elementos for ímpar, a mediana corresponde ao valor que ocupa a posição central do vetor ordenado. Se for par, a mediana é calculada como a média aritmética dos dois valores centrais.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>Trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>Devolve o valor da mediana. </dd></dl>

</div>
</div>
<a id="a6c61fb9ebb5d421733e5ecf3868e0661" name="a6c61fb9ebb5d421733e5ecf3868e0661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c61fb9ebb5d421733e5ecf3868e0661">&#9670;&#160;</a></span>novomistura()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void novomistura </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função pede que seja introduzidos 18 novos valores para um novo vetor, e de seguida mistura metade do vetor principal com metade desse novo vetor. </p>
<p>Esta função recebe os valores do vetor principal com 18 números dados pelo utilizador e seguidamente pede que sejam introduzidos 18 novos valores seguindo os principios do vetor principal (entre 1 e 11), criando assim um novo vetor. Com os dois vetores procede à mistura de metade do vetor principal com metade do novo vetor introduzido. De seguida imprime esse novo vetor na tela do usuario.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>Um vetor resultado da soma das duas metades, com metade do tamanho do principal respetivamente. </dd></dl>

</div>
</div>
<a id="a231ecd5239a28be99f55b277d1a87ba9" name="a231ecd5239a28be99f55b277d1a87ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231ecd5239a28be99f55b277d1a87ba9">&#9670;&#160;</a></span>ordenarsimetricos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ordenarsimetricos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função recebe o vetor com 18 valores dados pelo utilizador e ordena-os por ordem crescente dos seus valores simétricos. </p>
<p>Esta função compara valores adjacentes, trocando-os de lugar caso o VET[k] &lt; VET[k+1]. Assim, percorre todos os valores do vetor até que o último valor seja o maior, na sua forma simétrica. De seguida, volta a repetir o processo mas desta vez vai até ao penúltimo elemento do vetor, pois o último já está no seu devido lugar. O programa acaba quando deixa todos os valores na ordenação correta, quando k &lt; n - 1 - i. E, no fim, a função imprime o vetor ordenado, ordem crescente dos seus valores simétricos.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>o vetor ordenado de forma crescente dos seus valores simétricos. </dd></dl>

</div>
</div>
<a id="a208c78ecb1a4af1d7b03ef6708922419" name="a208c78ecb1a4af1d7b03ef6708922419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208c78ecb1a4af1d7b03ef6708922419">&#9670;&#160;</a></span>somametades()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void somametades </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>VET</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta função soma a primeira metade do vetor com a sua segunda criando um vetor com metade do tamanho. </p>
<p>Esta função recebe os valores do vetor principal com 18 números dados pelo utilizador percorrendo os mesmos e soma cada elemento da primeira metade do vetor com o elemento correspondente da segunda metade, obtendo assim um vetor com metade do tamanho. De seguida imprime esse mesmo vetor na tela do usuario.</p>
<dl class="params"><dt>Parâmetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">VET[]</td><td>trata-se do vetor recebido pela função (vetor principal) e o </td></tr>
    <tr><td class="paramname">n</td><td>o seu respetivo tamanho.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Retorna</dt><dd>Um vetor resultado da soma das duas metades, com metade do tamanho do principal respetivamente. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Gerado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
